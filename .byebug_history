exit
    ticket = Trees::Ticket::Build.new(params["data"]).call
params["data"]
params
    ticket = Trees::Ticket::Build.new(params).call
params.to_h
params.to_json
params
continue
obj
@params
obj
                        obj =ExcavationInfo.create(
                            id: Faker::Number.number(digits: 8),
                            type_of_work: @params[:TypeOfWork],
                            work_done_for: @params[:WorkDoneFor],
                            project_duration: @params[:ProjectDuration],
                            project_start_date: @params[:ProjectStartDate],
                            explosives: @params[:Explosives],
                            horizontal_boring: @params[:UnderGroundOverhead],
                            white_lined: @params[:Whitelined],
                            locate_instructions: @params[:LocateInstructions],
                            remarks: @params[:Remarks],
                            digsite_infos_id: digsite_infos_id
                        )
continue
@params[:UnderGroundOverhead]
@params
@params[:UndergroundOverhead]
                        ExcavationInfo.create(
                            id: Faker::Number.number(digits: 8),
                            type_of_work: @params[:TypeOfWork],
                            work_done_for: @params[:WorkDoneFor],
                            project_duration: @params[:ProjectDuration],
                            project_start_date: @params[:ProjectStartDate],
                            explosives: @params[:Explosives],
                            under_ground_over_head: @params[:UndergroundOverhead],
                            horizontal_boring: @params[:HorizontalBoring],
                            white_lined: @params[:Whitelined],
                            locate_instructions: @params[:LocateInstructions],
                            remarks: @params[:Remarks],
                            digsite_infos_id: digsite_infos_id
                        )
ExcavationInfo
@params[:HorizontalBoring]
@params
continue
@params[:UnderGroundOverhead]
@params
                service_area = Contexts::ServiceAreas::Commands::Build.new.call(
                    primary_service_area_codes_id: primary_service_area.id, 
                    additional_service_area_codes_id: additional_service_area.id
                )
continue
                service_area = Contexts::ServiceAreas::Commands::Build.new.call(
                    primary_service_area_codes_id: primary_service_area.id, 
                    additional_service_area_codes_id: additional_service_area.id
                )
continue
@params[:AdditionalServiceAreaCodes][:SACode]
@params[:AdditionalServiceAreaCodes]["SACode"]
@params[
@params["SACode"]
@params["SACODE"]
@params[:SACODE]
@params[:AdditionalServiceAreaCodes]
@params[:PrimaryServiceAreaCode]@params[:AdditionalServiceAreaCodes]
@params[:PrimaryServiceAreaCode]
                primary_service_area = Contexts::PrimaryServiceAreas::Commands::Build.new(
                    @params[:PrimaryServiceAreaCode]
                ).call
primary_service_area.id
continue
PrimaryServiceAreaCode.find(object.primary_service_area_codes_id)
PrimaryServiceArea.find(object.primary_service_area_codes_id)
object.primary_service_area_codes_id
primaryRepository.load(object.primary_service_area_codes_id)
continue
Contexts::Itois::Repository.new.load(object.itoi_ids)
continue
                                itoi_ids << itoi.id
                                itoi = Contexts::Itois::Commands::Build.new(itoi).call
                                args = itoi.as_json.merge(id: Faker::Number.number(digits: 8))
continue
                        itoi_ids << Contexts::Itois::Commands::Build.new(itoi).call.id
                        itoi = itoi.as_json.merge(id: Faker::Number.number(digits: 8))
itoi.as_json
itoi.to_h
itoi
                        itoi = itoi.to_h.merge(id: Faker::Number.number(digits: 8))
exit
@params
params
continue
      expect(Itoi.find(intersection.itoi_ids).size).to eq(2)
Itoi.find(intersection.itoi_ids)
Itoi.find(id: intersection.itoi_ids)
exit
Itoi.where(id: intersection.itoi_ids)
Itoi.where(id: intersection.itoi_ids).size
Itoi.where(id: intersection.itoi_ids).siz
Itoi.where(intersection.itoi_ids).size
exit
size.size
size = Itoi.where(id: intersection.itoi_ids)
Itoi.where(id: intersection.itoi_ids)
Itoi.where(intersection.itoi_ids)
Itoi.where(intersection.itoi_ids).size
      expect(Itoi.where(intersection.itoi_ids).size).to eq(2)
      expect(Itoi.where(intersection.itoi_ids).size).to be_bigger_than(0)
      expect(Itoi.where(intersection.itoi_ids)).to be_bigger_than(0)
      expect(Itoi.where(intersection.itoi_ids)).to be_valid
      expect(Itoi.find(intersection.itoi_ids)).to be_valid
Itoi.find(id: intersection.itoi_ids)
Itoi.where(id: intersection.itoi_ids)
intersection.itoi_ids
intersection
Intersection.where(id: intersection.itoi_ids)
continue
excavator[:crew_on_site].class
exit
      validation = arrayTypeValidation.call(additional_service_area.sa_code)
      arrayTypeValidation = ->(sa_code) { sa_code.each{|obj| return expect(obj.class).to be(String)} }
      arrayTypeValidation = ->(sa_code) { sa_code.each{|obj| expect(obj.class).to be(String)} }
      validation = arrayTypeValidation.call(additional_service_area.sa_code)
additional_service_area.sa_code
      arrayTypeValidation.call(additional_service_area.sa_code).each do |type|
        expect(type).to be(String)
      end
type
      arrayTypeValidation.call(additional_service_area.sa_code).each do |type|
        expect(type).to be(String)
      end
      arrayTypeValidation.call(additional_service_area.sa_code).include?(String) || !arrayTypeValidation.call(additional_service_area.sa_code).include?(String)
      arrayTypeValidation.call(additional_service_area.sa_code).include?(String) && !arrayTypeValidation.call(additional_service_area.sa_code).include?(String)
additional_service_area.sa_code = ["xd", 1]
      arrayTypeValidation.call(additional_service_area.sa_code).include?(String) && !arrayTypeValidation.call(additional_service_area.sa_code).include?(String)
      arrayTypeValidation.call(additional_service_area.sa_code).include?(String)
      arrayTypeValidation = ->(sa_code) { sa_code.map{|obj| obj.class} }
      arrayTypeValidation.call(additional_service_area.sa_code).include?(String)
      arrayTypeValidation = ->(sa_code) { sa_code.exists?{|obj| obj.class} }
arrayTypeValidation.call(additional_service_area.sa_code)
rrayTypeValidation.call(additional_service_area.sa_code)
      arrayTypeValidation = ->(sa_code) { sa_code.exists?{|obj| obj.class} }
      arrayTypeValidation.call(additional_service_area.sa_code).exists?(String)
arrayTypeValidation.call
      arrayTypeValidation = ->(sa_code) { sa_code.map{|obj| obj.class} }
      arrayTypeValidation.call.exists?(String)
      arrayTypeValidation = ->(sa_code) { sa_code.map{|obj| obj.class} }
      valid_if_array_stirng? = ->(sa_code) { sa_code.map{|obj| obj.class == String} }
valid_string_objects.call(additional_service_area.sa_code)
valid_string_objects.call
      valid_string_objects = ->(sa_code) { sa_code.map{|obj| obj.class == String} }
valid_string_objects.call
      expect(valid_string_objects.call).to be(true)
      expect(additional_service_area.sa_code.class).to be(Array)
additional_service_area.sa_code.class
continue
      expect(additional_service_area.sa_code.class).to be_a(Array)
valid_string_objects.call(["S", 1])      expect(additional_service_area.sa_code.class).to be_a(Array)
valid_string_objects.call(["S", 1])
      valid_string_objects = ->(sa_code) { sa_code.map{|obj| obj.class == String} }
to_be_string.call(["S", 1])
      to_be_string = ->(sa_code) { sa_code.map{|obj| obj.class == String} }
to_be_string.call(additional_service_area.sa_code)
additional_service_area.sa_code
      to_be_string = ->(sa_code) { sa_code.each{|obj| 
        byebug
        return obj.class == String} }
additional_service_area.sa_code
to_be_string.call(additional_service_area.sa_code)
      to_be_string = ->(sa_code) { sa_code.each{|obj| 
        byebug
        obj.class == String} }
exit
to_be_string.call(["S", 1])
      to_be_string = ->(sa_code) { sa_code.each{|obj| 
        byebug
        obj.class == String} }
      to_be_string = ->(sa_code) { byebug sa_code.each{|obj| obj.class == String} }
to_be_string.call(["S", 1])
      to_be_string = ->(sa_code) { byebug sa_code.each{|obj| obj.class == String} }
to_be_string.call(["S", 1])
      to_be_string = ->(sa_code) { sa_code.reject{|obj| obj.class == String} }
to_be_string.call(["S", 1])
      to_be_string = ->(sa_code) { sa_code.each{|obj| obj.class == String} }
create(:service_area, primary_service_area_codes_id: nil, additional_service_area_codes_id: nil)
expect { digsite_info }.to raise_error
      expect(digsite_info).to raise_error
      expect(digsite_info).to be_valid
continue
exit
                adress_info = Trees::AdressInfo::Build.new(@params[:AddressInfo]).call
exit
Trees::AdressInfo
Trees::AdressInfos
exit
Trees::AdressInfos
Trees::AdressInfo
exit
Trees
Trees::AdressInfo
Trees::AdressInfos
Trees
exit
continue
                        NearStreet.create(
continue
                        TicketDates.create(id: Faker::Number.number(digits: 8), 
                            response_due_date_time: response_due_date_time, 
                            transmission_date_time: transmission_date_time,
                            legal_date_time: legal_date_time,
                            request_taken_date_time: request_taken_date_time,
                            restake_date: restake_date,
                            expiration_date: expiration_date,
                            lpm_metting_accept_due_date: lpm_metting_accept_due_date,
                            overhead_begin_date: overhead_begin_date,
                            overhead_end_date: overhead_end_date
                        )
                    overhead_end_date = @params[:OverheadEndDate]
                    lpm_metting_accept_due_date = @params[:LPMmettingAcceptDueDate]
                    overhead_begin_date = @params[:OverheadBeginDate]
                    expiration_date = @params[:ExpirationDate]
                    restake_date = @params[:RestakeDate]
                    request_taken_date_time = @params[:RequestTakenDateTime]
                    legal_date_time = @params[:LegalDateTime]
                    transmission_date_time = @params[:TransmissionDateTime]
                    response_due_date_time = @params[:ResponseDueDateTime]
continue
exit
@params
                    transmission_date_time = @params[:TransmissionDateTime]
                    response_due_date_time = @params[:ResponseDueDateTime]
                    transmission_date_time = @params[:TransmissionDateTime]
                    legal_date_time = @params[:LegalDateTime]
                    request_taken_date_time = @params[:RequestTakenDateTime]
                    restake_date = @params[:RestakeDate]
                    expiration_date = @params[:ExpirationDate]
                    overhead_begin_date = @params[:OverheadBeginDate]
                    lpm_metting_accept_due_date = @params[:LPMmettingAcceptDueDate]
                    overhead_end_date = @params[:OverheadEndDate]
continue
exit
continue
 @params[:ResponseDueDateTime]
@params
continue
exit
ticket_dates = Contexts::TicketsDates::Commands::Build.new(@params[:DateTimes]).call
continue
exit
TicketDates
TicketDate
            service_area = Trees::ServiceArea::Build.new(@params[:ServiceArea]).call
            excavator = Trees::Excavator::Build.new(@params[:Excavator]).call
            excavation_info = Trees::ExcavationInfo::Build.new(@params[:ExcavationInfo]).call
