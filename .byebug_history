continue
      expect(Itoi.find(intersection.itoi_ids).size).to eq(2)
Itoi.find(intersection.itoi_ids)
Itoi.find(id: intersection.itoi_ids)
exit
Itoi.where(id: intersection.itoi_ids)
Itoi.where(id: intersection.itoi_ids).size
Itoi.where(id: intersection.itoi_ids).siz
Itoi.where(intersection.itoi_ids).size
exit
size.size
size = Itoi.where(id: intersection.itoi_ids)
Itoi.where(id: intersection.itoi_ids)
Itoi.where(intersection.itoi_ids)
Itoi.where(intersection.itoi_ids).size
      expect(Itoi.where(intersection.itoi_ids).size).to eq(2)
      expect(Itoi.where(intersection.itoi_ids).size).to be_bigger_than(0)
      expect(Itoi.where(intersection.itoi_ids)).to be_bigger_than(0)
      expect(Itoi.where(intersection.itoi_ids)).to be_valid
      expect(Itoi.find(intersection.itoi_ids)).to be_valid
Itoi.find(id: intersection.itoi_ids)
Itoi.where(id: intersection.itoi_ids)
intersection.itoi_ids
intersection
Intersection.where(id: intersection.itoi_ids)
continue
excavator[:crew_on_site].class
exit
      validation = arrayTypeValidation.call(additional_service_area.sa_code)
      arrayTypeValidation = ->(sa_code) { sa_code.each{|obj| return expect(obj.class).to be(String)} }
      arrayTypeValidation = ->(sa_code) { sa_code.each{|obj| expect(obj.class).to be(String)} }
      validation = arrayTypeValidation.call(additional_service_area.sa_code)
additional_service_area.sa_code
      arrayTypeValidation.call(additional_service_area.sa_code).each do |type|
        expect(type).to be(String)
      end
type
      arrayTypeValidation.call(additional_service_area.sa_code).each do |type|
        expect(type).to be(String)
      end
      arrayTypeValidation.call(additional_service_area.sa_code).include?(String) || !arrayTypeValidation.call(additional_service_area.sa_code).include?(String)
      arrayTypeValidation.call(additional_service_area.sa_code).include?(String) && !arrayTypeValidation.call(additional_service_area.sa_code).include?(String)
additional_service_area.sa_code = ["xd", 1]
      arrayTypeValidation.call(additional_service_area.sa_code).include?(String) && !arrayTypeValidation.call(additional_service_area.sa_code).include?(String)
      arrayTypeValidation.call(additional_service_area.sa_code).include?(String)
      arrayTypeValidation = ->(sa_code) { sa_code.map{|obj| obj.class} }
      arrayTypeValidation.call(additional_service_area.sa_code).include?(String)
      arrayTypeValidation = ->(sa_code) { sa_code.exists?{|obj| obj.class} }
arrayTypeValidation.call(additional_service_area.sa_code)
rrayTypeValidation.call(additional_service_area.sa_code)
      arrayTypeValidation = ->(sa_code) { sa_code.exists?{|obj| obj.class} }
      arrayTypeValidation.call(additional_service_area.sa_code).exists?(String)
arrayTypeValidation.call
      arrayTypeValidation = ->(sa_code) { sa_code.map{|obj| obj.class} }
      arrayTypeValidation.call.exists?(String)
      arrayTypeValidation = ->(sa_code) { sa_code.map{|obj| obj.class} }
      valid_if_array_stirng? = ->(sa_code) { sa_code.map{|obj| obj.class == String} }
valid_string_objects.call(additional_service_area.sa_code)
valid_string_objects.call
      valid_string_objects = ->(sa_code) { sa_code.map{|obj| obj.class == String} }
valid_string_objects.call
      expect(valid_string_objects.call).to be(true)
      expect(additional_service_area.sa_code.class).to be(Array)
additional_service_area.sa_code.class
continue
      expect(additional_service_area.sa_code.class).to be_a(Array)
valid_string_objects.call(["S", 1])      expect(additional_service_area.sa_code.class).to be_a(Array)
valid_string_objects.call(["S", 1])
      valid_string_objects = ->(sa_code) { sa_code.map{|obj| obj.class == String} }
to_be_string.call(["S", 1])
      to_be_string = ->(sa_code) { sa_code.map{|obj| obj.class == String} }
to_be_string.call(additional_service_area.sa_code)
additional_service_area.sa_code
      to_be_string = ->(sa_code) { sa_code.each{|obj| 
        byebug
        return obj.class == String} }
additional_service_area.sa_code
to_be_string.call(additional_service_area.sa_code)
      to_be_string = ->(sa_code) { sa_code.each{|obj| 
        byebug
        obj.class == String} }
exit
to_be_string.call(["S", 1])
      to_be_string = ->(sa_code) { sa_code.each{|obj| 
        byebug
        obj.class == String} }
      to_be_string = ->(sa_code) { byebug sa_code.each{|obj| obj.class == String} }
to_be_string.call(["S", 1])
      to_be_string = ->(sa_code) { byebug sa_code.each{|obj| obj.class == String} }
to_be_string.call(["S", 1])
      to_be_string = ->(sa_code) { sa_code.reject{|obj| obj.class == String} }
to_be_string.call(["S", 1])
      to_be_string = ->(sa_code) { sa_code.each{|obj| obj.class == String} }
create(:service_area, primary_service_area_codes_id: nil, additional_service_area_codes_id: nil)
expect { digsite_info }.to raise_error
      expect(digsite_info).to raise_error
      expect(digsite_info).to be_valid
continue
exit
                adress_info = Trees::AdressInfo::Build.new(@params[:AddressInfo]).call
exit
Trees::AdressInfo
Trees::AdressInfos
exit
Trees::AdressInfos
Trees::AdressInfo
exit
Trees
Trees::AdressInfo
Trees::AdressInfos
Trees
exit
continue
                        NearStreet.create(
continue
                        TicketDates.create(id: Faker::Number.number(digits: 8), 
                            response_due_date_time: response_due_date_time, 
                            transmission_date_time: transmission_date_time,
                            legal_date_time: legal_date_time,
                            request_taken_date_time: request_taken_date_time,
                            restake_date: restake_date,
                            expiration_date: expiration_date,
                            lpm_metting_accept_due_date: lpm_metting_accept_due_date,
                            overhead_begin_date: overhead_begin_date,
                            overhead_end_date: overhead_end_date
                        )
                    overhead_end_date = @params[:OverheadEndDate]
                    lpm_metting_accept_due_date = @params[:LPMmettingAcceptDueDate]
                    overhead_begin_date = @params[:OverheadBeginDate]
                    expiration_date = @params[:ExpirationDate]
                    restake_date = @params[:RestakeDate]
                    request_taken_date_time = @params[:RequestTakenDateTime]
                    legal_date_time = @params[:LegalDateTime]
                    transmission_date_time = @params[:TransmissionDateTime]
                    response_due_date_time = @params[:ResponseDueDateTime]
continue
exit
@params
                    transmission_date_time = @params[:TransmissionDateTime]
                    response_due_date_time = @params[:ResponseDueDateTime]
                    transmission_date_time = @params[:TransmissionDateTime]
                    legal_date_time = @params[:LegalDateTime]
                    request_taken_date_time = @params[:RequestTakenDateTime]
                    restake_date = @params[:RestakeDate]
                    expiration_date = @params[:ExpirationDate]
                    overhead_begin_date = @params[:OverheadBeginDate]
                    lpm_metting_accept_due_date = @params[:LPMmettingAcceptDueDate]
                    overhead_end_date = @params[:OverheadEndDate]
continue
exit
continue
 @params[:ResponseDueDateTime]
@params
continue
exit
ticket_dates = Contexts::TicketsDates::Commands::Build.new(@params[:DateTimes]).call
continue
exit
TicketDates
TicketDate
            service_area = Trees::ServiceArea::Build.new(@params[:ServiceArea]).call
            excavator = Trees::Excavator::Build.new(@params[:Excavator]).call
            excavation_info = Trees::ExcavationInfo::Build.new(@params[:ExcavationInfo]).call
            ticket_dates = Contexts::TicketDates::Commands::Build.new(@params[:DateTimes]).call
continue
            service_area = Contexts::ServiceAreas::Commands::Build.new.call(
                primary_service_area_codes_id: primary_service_area.id, 
                additional_service_area_codes_id: additional_service_area.id
            )
            primary_service_area = Contexts::PrimaryServiceAreas::Commands::Build.new(
                @params[:PrimaryServiceAreaCode]
            ).call
            additional_service_area = Contexts::AdditionalServiceAreas::Commands::Build.new(
                @params[:AdditionalServiceAreaCodes]
            ).call
@params            additional_service_area = Contexts::AdditionalServiceAreas::Commands::Build.new(
                @params[:AdditionalServiceAreaCodes]
            ).call
            primary_service_area = Contexts::PrimaryServiceAreas::Commands::Build.new(
                @params[:PrimaryServiceAreaCode]
            ).call
@params
continue
                        NearStreet.create(
continue
                        NearStreet.create(
                            id: Faker::Number.number(digits: 8),
                            state: @params[:State],
                            county: @params[:County],
                            place: @params[:Place],
                            prefix: @params[:Prefix],
                            name: @params[:Name],
                            dig_type: @params[:Type],
                            suffix: @params[:Suffix]
                        )
continue
            adress_info = Contexts::AdressInfos::Commands::Build.new(@params).call(
                adress_id: adress.id,
                street_id: street.id    
            )
            adress_info = Contexts::AdressInfos::Commands::Build.new(@params).call(
                adress_digsite_id: adress.id,
                street_digsite_id: street.id    
            )
adress.id
adress
continue
            adress = Contexts::AdressDigsites::Commands::Build.new(
                @params[:Adress]
            ).call
continue
exit
@params[:Adress]
            adress = Contexts::AdressDigsites::Commands::Build.new(
                @params[:Adress]
            ).call
continue
            adress = Contexts::AdressDigsites::Commands::Build.new(
                @params[:Adress]
            ).call
@params
            adress = Contexts::AdressDigsites::Commands::Build.new(
                @params[:Addres]
            ).call
continue
            adress = Contexts::AdressDigsites::Commands::Build.new(
                @params[:Addres]
            ).call
@params[:Adress]
@params
@params[:Address]
continue
                        AdressDigsite.create(id: Faker::Number.number(digits: 8), adress_num: @params[:AdressNum])
@params
continue
            street = Contexts::StreetDigsites::Commands::Build.new(
                @params[:Street]
            ).call
@params[:Adress]
            adress = Contexts::AdressDigsites::Commands::Build.new(
                @params[:Address]
            ).call
@params
adress
@params
continue
exit
continue
@params
continue
@params[:AddressInfo]
@params[:AdressInfo]
@params
continue
exit
@params
